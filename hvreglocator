import argparse
import subprocess
import os
import sys
from Bio import SeqIO
import numpy as np
from scipy import stats

def run_command(command, input_file=None, output_file=None):
    infile = open(input_file, 'r') if input_file else None
    outfile = open(output_file, 'w') if output_file else None
    try:
        process = subprocess.Popen(command, stdin=infile, stdout=outfile if outfile else subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        _, stderr = process.communicate()
        if process.returncode != 0:
            print(f"Error: {stderr.decode('utf-8')}")
            return False
    finally:
        if infile:
            infile.close()
        if outfile:
            outfile.close()
    return True

def process_sra(input_id, working_directory):
    # Define file paths with Wdir directory
    fastq_dump_file = os.path.join(working_directory, "fastq_dump_output.txt")
    fastp_file = os.path.join(working_directory, "fastp_output.txt")
    sed_file = os.path.join(working_directory, "sed_output.txt")
    mafft_file = os.path.join(working_directory, "mafft_output.txt")
    final_output_file = os.path.join(working_directory, "hvreglocator_output.txt")

    # Define and run each command
    print("Running fastq-dump...")
    fastq_dump_command = f"fastq-dump --split-files --defline-seq '@$ac.$si.$sg/$ri' --defline-qual '+' -Z {input_id} | head -n 4096 > {fastq_dump_file}"
    if not run_command(fastq_dump_command):
        print("Error in fastq-dump command")
        return False

    print("Running fastp...")
    fastp_command = f"cat {fastq_dump_file} | fastp --stdin --stdout --interleaved_in --detect_adapter_for_pe > {fastp_file}"
    if not run_command(fastp_command):
        print("Error in fastp command")
        return False

    print("Running sed...")
    sed_command = f"cat {fastp_file} | sed -n '1~4s/^@/>/p;2~4p' > {sed_file}"
    if not run_command(sed_command):
        print("Error in sed command")
        return False

    print("Running mafft...")
    mafft_command = f"mafft --nuc --keeplength --addfragments {sed_file} ecoli.fa > {mafft_file}"
    if not run_command(mafft_command):
        print("Error in mafft command")
        return False

    print("Running hvreglocator...")
    hvreglocator_command = f"python hvreglocator_mod.py {mafft_file} > {final_output_file}"
    if not run_command(hvreglocator_command):
        print("Error in hvreglocator_mod.py command")
        return False

    print("Process completed successfully. Output saved in:", final_output_file)
    return final_output_file

def process_fasta(input_fasta):
    sequences = []
    for record in SeqIO.parse(input_fasta, "fasta"):
        sequences.append(record)
    sequences = sequences[1:]  # Dropping first sequence (ref full-length ecoli 16s)

    sequence_counts = {}
    # Count the occurrences of each sequence (ignoring /1 or /2)
    for record in sequences:
        sequence_id = record.id.rsplit('/', 1)[0]  # Remove the /1 or /2 part
        sequence_counts[sequence_id] = sequence_counts.get(sequence_id, 0) + 1

    ids_to_keep = []
    for k, v in sequence_counts.items():
        if v == 2:
            ids_to_keep.append(k)

    # Filter the sequences
    filtered_sequences = []
    for record in sequences:
        if record.id.rsplit('/', 1)[0] in ids_to_keep:
            filtered_sequences.append(record)

    # Define variables
    counts = []  # store counts for each sequence
    countsmat = []  # store all counts for all sequences in matrix
    count = 1

    # Read each fasta sequence and count the number of spacers ("-")
    for record in sequences:
        # Count the number of spacers at the beginning of the sequence
        iteration = 0
        for a, b in zip(list(record.seq), list(record.seq)[1:]):
            if a == "-":
                if a == b:
                    count += 1
                else:
                    counts.append(count)
                    count = 1
            else:
                if iteration == 0:
                    counts.append(1)
                break
            iteration += 1

        # Count the number of spacers at the end of the sequence (reversed)
        iteration = 0
        for a, b in zip(list(reversed(record.seq)), list(reversed(record.seq))[1:]):
            if a == "-":
                if a == b:
                    count += 1
                else:
                    counts.append(len(record.seq) - count)
                    count = 1
            else:
                if iteration == 0:
                    counts.append(1)
                break
            iteration += 1

        countsmat.append(counts)
        count = 1
        counts = []

    # Calculate average of all start / end positions at alignment
    column_start = [row[0] for row in countsmat]
    column_end = [row[1] for row in countsmat]

    column_start = np.array(column_start)
    column_end = np.array(column_end)

    mode_start = stats.mode(column_start)
    mode_end = stats.mode(column_end)
    start_pos_avg = mode_start.mode.astype(int)
    end_pos_avg = mode_end.mode.astype(int)

    # Figure out spanning region (for Paired-end)
    region_start = None
    region_end = None

    # Forward primer
    if start_pos_avg <= 69:
        region_start = 1
    elif 99 <= start_pos_avg <= 157:
        region_start = 2
    elif 227 <= start_pos_avg <= 440:
        region_start = 3
    elif 500 <= start_pos_avg <= 590:
        region_start = 4
    elif 650 <= start_pos_avg <= 828:
        region_start = 5
    elif 857 <= start_pos_avg <= 1000:
        region_start = 6
    elif 1036 <= start_pos_avg <= 1119:
        region_start = 7
    elif 1158 <= start_pos_avg <= 1243:
        region_start = 8
    elif 1295 <= start_pos_avg <= 1435:
        region_start = 9

    # Reverse primer
    if end_pos_avg >= 1465:
        region_end = 9
    elif 1295 <= end_pos_avg <= 1435:
        region_end = 8
    elif 1158 <= end_pos_avg <= 1243:
        region_end = 7
    elif 1036 <= end_pos_avg <= 1119:
        region_end = 6
    elif 857 <= end_pos_avg <= 1000:
        region_end = 5
    elif 650 <= end_pos_avg <= 828:
        region_end = 4
    elif 500 <= end_pos_avg <= 590:
        region_end = 3
    elif 227 <= end_pos_avg <= 440:
        region_end = 2
    elif 99 <= end_pos_avg <= 157:
        region_end = 1

    print("Alignment start:", start_pos_avg)
    print("Alignment end:", end_pos_avg)
    print("Hypervariable region span: ", f"V{region_start}-V{region_end}")

def main():
    parser = argparse.ArgumentParser(description="HVRegLocator: Process SRA data or FASTA file to locate hypervariable regions.")
    parser.add_argument("command", choices=["sra", "fasta"], help="Choose 'sra' to process SRA data or 'fasta' to process a FASTA file")
    parser.add_argument("-r", "--run-id", help="SRA Run ID for processing (required for 'sra' command)")
    parser.add_argument("-f", "--fasta-file", help="Input FASTA file (required for 'fasta' command)")
    
    args = parser.parse_args()

    if args.command == "sra":
        if not args.run_id:
            parser.error("The 'sra' command requires the --run-id argument")
        
        working_directory = "Wdir"
        if not os.path.exists(working_directory):
            os.makedirs(working_directory)
        
        output_file = process_sra(args.run_id, working_directory)
        if output_file:
            process_fasta(output_file)
    
    elif args.command == "fasta":
        if not args.fasta_file:
            parser.error("The 'fasta' command requires the --fasta-file argument")
        
        process_fasta(args.fasta_file)

if __name__ == "__main__":
    main()